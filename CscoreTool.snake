rule makeHiCsummary:
    input:
        lambda wc: expand(
            'dat/matrix/{{region}}/base/raw/{{group}}-{rep}-{{region}}.{BASE_BIN}-{{pm}}.h5',
            rep=HiC.groups()[wc.group], BASE_BIN=BASE_BIN)
    output:
        'dat/matrix/{region}/{group}-{region}-{pm}.HiCsummary.gz'
    group:
        'CscoreTool'
    log:
        'logs/makeHiCsummary/{group}-{region}-{pm}.log'
    conda:
        f'{ENVS}/hicexplorer.yaml'
    shell:
        'python {SCRIPTS}/makeHiCsummary.py {input} | gzip > {output} 2> {log}'


rule generateEqualLengthBed:
    input:
        config['regions']
    output:
        'dat/genome/equalLengthRegions-{bin}.bed'
    log:
        'logs/generateEqualLengthBed-{bin}.log'
    conda:
        f'{ENVS}/python3.yaml'
    shell:
        'python {SCRIPTS}/generateEqualLengthBed.py {input} '
        '{wildcards.bin} > {output} 2> {log}'


def getChrPrefix(wc):
    """ Add 'chr' prefix if required since Cscore expects it. """
    chrom = REGIONS['chr'][wc.region]
    if not chrom.startswith('chr'):
        prefix = 'chr'
    else:
        prefix = ''
    return prefix


rule CscoreTool:
    input:
        windows = rules.generateEqualLengthBed.output,
        summary = rules.makeHiCsummary.output
    output:
        expand(
            'dat/Cscore/{{region}}/{{bin}}/{{group}}-{{region}}-{{bin}}-{{pm}}-Cscore{ext}',
            ext=['bias.txt', '_hh.txt', '_cscore.txt', '_cscore.bedgraph'])
    params:
        minDis = 1000000,
        chrPrefix = getChrPrefix,
        chr = lambda wc: REGIONS['chr'][wc.region],
        prefix = lambda wc: f'dat/Cscore/{wc.region}/{wc.bin}/{wc.group}-{wc.region}-{wc.bin}-{wc.pm}-Cscore'
    group:
        'CscoreTool'
    threads:
        THREADS
    log:
        'logs/CscoreTool/{group}-{region}-{bin}-{pm}.log'
    shell:
        '{SCRIPTS}/CscoreTool1.1 {input.windows} <(zcat {input.summary}) {params.prefix} '
        '{threads} {params.minDis} {params.chrPrefix}{params.chr} &> {log}'


rule extractRegion:
    input:
        genome = 'dat/genome/{cellType}.fa.gz',
        index = 'dat/genome/{cellType}.fa.gz.fai'
    output:
        temp('dat/Cscore/{cellType}-{region}.fa')
    params:
        chr = lambda wc: REGIONS['chr'][wc.region],
        start = lambda wc: REGIONS['start'][wc.region],
        end = lambda wc: REGIONS['end'][wc.region]
    group:
        'CscoreTool'
    log:
        'logs/extractRegion/{cellType}-{region}.log'
    conda:
        f'{ENVS}/samtools.yaml'
    shell:
        'samtools faidx {input.genome} '
        '{params.chr}:{params.start}-{params.end} > {output} 2> {log}'


def getGenome(wc):
    cellType = HiC.sample2Cell()[wc.group]
    return f'dat/Cscore/{cellType}-{wc.region}.fa'


rule orientCscore:
    input:
        genome = getGenome,
        cscore = 'dat/Cscore/{region}/{bin}/{group}-{region}-{bin}-{pm}-Cscore_cscore.bedgraph',
    output:
        'dat/Cscore/{region}/{bin}/{group}-{region}-{bin}-{pm}-Cscore-reorient.bedgraph'
    group:
        'CscoreTool'
    log:
        'logs/orientCscore/{group}-{region}-{bin}-{pm}.log'
    conda:
        f'{ENVS}/python3.yaml'
    shell:
        '{SCRIPTS}/orientCscore.py {input.cscore} {input.genome} '
        '> {output} 2> {log}'


rule Bedgraph_to_Bed:
    input:
        'dat/Cscore/{region}/{bin}/{group}-{region}-{bin}-{pm}-Cscore-reorient.bedgraph'
    output:
        'dat/Cscore/{region}/{bin}/{group}-{region}-{bin}-{pm}-Cscore_cscore.bed'
    group:
        'CscoreTool'
    log:
        'logs/Bedgraph_to_Bed/{group}-{region}-{bin}-{pm}.log'
    conda:
        f'{ENVS}/python3.yaml'
    shell:
        '{SCRIPTS}/Bedgraph_to_Bed.py {input} > {output} 2> {log}'


rule computeSwitchScore:
    input:
        'dat/Cscore/{region}/{bin}/{group1}-{region}-{bin}-{pm}-Cscore_cscore.bed',
        'dat/Cscore/{region}/{bin}/{group2}-{region}-{bin}-{pm}-Cscore_cscore.bed'
    output:
        'dat/Cscore/{region}/{bin}/{group1}-vs-{group2}-{region}-{bin}-{pm}-switchScore.bed'
    group:
        'CscoreTool'
    log:
        'logs/computeSwitchScore/{group1}-vs-{group2}-{region}-{bin}-{pm}.log'
    conda:
        f'{ENVS}/python3.yaml'
    shell:
        '{SCRIPTS}/computeSwitchScore.py {input} > {output} 2> {log}'
